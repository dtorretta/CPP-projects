int x = 42;
float y = (float)x; // C-style cast ‚ùå

int x = 42;
float y = static_cast<float>(x); // C++-style cast ‚úÖ

‚úÖ S√≠ pod√©s usar static_cast si:
Convert√≠s entre tipos primitivos compatibles (int, float, double, etc.).
Convert√≠s hacia o desde void* (con cuidado).


üõë No deb√©s usar static_cast si:
Est√°s eliminando const de un puntero o referencia ‚Üí us√° const_cast.
Est√°s bajando de clase base a derivada con polimorfismo (y quer√©s que sea seguro en tiempo de ejecuci√≥n) ‚Üí us√° dynamic_cast.





metodos estaticos
- MiClase::miMetodoEstatico(); -- Pod√©s llamarlos sin crear un objeto.

class Math 
{
public:
    static int sum(int a, int b) 
};

int resultado = Math::sum(3, 4); // No hace falta crear un objeto Math


como funciona >>

std::istringstream iss("456xyz");
int val;
iss >> val;  // val ser√° 456  Cuando llega a 'x', que no es un d√≠gito, se detiene y guarda 456 en val.


üõë el operador >> sabe qu√© tipo debe extraer porque t√∫ le dices en qu√© tipo de variable guardarlo.

Si haces iss >> intVariable; ‚Üí el stream intentar√° extraer un n√∫mero entero.
Si haces iss >> doubleVariable; ‚Üí intentar√° extraer un n√∫mero de punto flotante.
Si haces iss >> stringVariable; ‚Üí intentar√° extraer una palabra (hasta el siguiente espacio).
Si haces iss >> charVariable; ‚Üí extraer√° un solo car√°cter.


-------

std::istringstream iss("123 hello 4.56");

int a;
std::string b;
double c;

‚úÖiss >> a; // Extrae 123 como entero
‚úÖiss >> b; // Extrae "hello" como string
‚úÖiss >> c; // Extrae 4.56 como double


tipo de throw en try-catch

catch (const char* msg) --> Se usa cuando lanzas un literal de cadena (string literal) con throw "mensaje de error";
catch (std::exception &e) --> tiene el m√©todo .what() que devuelve un mensaje de error. Permite crear jerarqu√≠as de 
errores y manejar distintos tipos de excepciones de forma organizada.
para cada tipo de excepci√≥n que quieras manejar con detalle, deber√≠as crear una clase distinta

puedo combinar ambas





str.back() --> str[str.length() - 1]
str.substr
str.length()



/////////////
DE POINTER A INT Y VISCEVERSA (Para conversiones de bajo nivel como puntero <-> int)

reinterpret_cast --> se usa para convertir  PUNTEROS - INTS (y visceversa) de forma segura.
uintptr_t garantiza que pod√©s guardar la direcci√≥n de memoria sin p√©rdida.

    ‚úÖ return reinterpret_cast<uintptr_t>(ptr);  // pointer a int

    ‚úÖ return reinterpret_cast<Data*>(raw);    // int a pointer
    
    
Usamos reinterpret_cast porque no tiene nada que ver con herencia ni con jerarqu√≠as de clases. 
Solo queremos reinterpretar la direcci√≥n de memoria como n√∫mero y viceversa.
dynamic_cast solo sirve para conversiones entre tipos de clases con herencia



////////
RANDOMIZER

#include <cstdlib>  // para rand() y srand()
#include <ctime>    // para time()

srand(time(NULL));  // Inicializa la semilla del generador con el tiempo actual

    int random_number = rand();  // N√∫mero entre 0 y RAND_MAX
    std::cout << random_number << std::endl;
    
    
solo en main hacemos srand(time(NULL));

ya en cada otro archivo hacemos directo rand


rand() devuelve un n√∫mero entero aleatorio muy grande (entre 0 y RAND_MAX, que suele ser al menos 32767).
int r = rand() % 3;

le est√°s diciendo:
‚ÄúDame el resto de dividir ese n√∫mero grande entre 3.‚Äù


//////////
üß† ¬øQu√© es dynamic_cast?

sirve para conversiones entre tipos de clases con herencia
permite convertir de forma segura punteros o referencias entre tipos relacionados por herencia 
(especialmente √∫til en herencia polim√≥rfica).

‚úÖ ¬øCu√°ndo se usa?
Cuando tienes un puntero o una referencia a una clase base y quer√©s saber si realmente apunta a un objeto de una clase derivada.

requiere al menos un m√©todo virtual en la clase base (esto activa el sistema de RTTI = Run-Time Type Information). 
por eso tenemos virtual ~Base()