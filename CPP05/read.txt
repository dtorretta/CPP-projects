----EX00----
‚úÖ ¬øQu√© son las clases de excepci√≥n en C++?
Las clases de excepci√≥n son tipos especiales de clases que se usan para representar errores o situaciones excepcionales en un programa.
Cuando algo sale mal (por ejemplo, divisi√≥n por cero, archivo no encontrado, etc.), puedes "lanzar" (throw) una excepci√≥n, y despu√©s "atraparla" (catch)
para manejar el error sin que el programa se caiga.

Hereda de:
std::exception, (recomendado) o alguna de sus hijas 
std::runtime_error, 
std::invalid_argument, etc.

Puedes crear tus propias clases de excepci√≥n si quer√©s errores m√°s espec√≠ficos y personalizados.
No necesitan estar en Orthodox Canonical Form, porque no manejan recursos complejos.


esta clase puede ir aparte o se puede agregar dentro de una clase principal

üí° Cuando la asignamos entro de la clase. Dentro de los miembros publicos agregamos

----DEFINICION DE LA EXCEPCION----

class GradeTooHighException : public std::exception 
{
	public:
		const char* what() const throw();
};

üìå 'class' --> agrago la palabra CLASS
üìå 'GradeTooHighException' -->nombre de la clase
üìå ': public std::exception' --> significa que esta clase es una subclase de std::exception.
es esencial para que pueda ser lanzada (throw) y capturada (catch) como cualquier excepci√≥n est√°ndar.
(en otros Cependant, habiamos hecho 'class FragTrap : public ClapTrap')

üìå'const char*' --> va a devolver un puntero a un string
üìå'what()' --> funcion heredada de std::exception. vSiempre se llama what(). Es lo que C++ usa para imprimir el mensaje de una excepci√≥n.
üìå'const' --> Es obligatorio para que coincida exactamente con la definici√≥n en std::exception.
üìå'throw()' --> Significa: "esta funci√≥n no lanza excepciones". equivalente a noexcept



----DECLARACION DE LA EXCEPCION----

const char* Bureaucrat::GradeTooHighException::what() const throw() 
{
    return "Grade is too high!";
}

üìå 'const char*' --> igual que en la definicion
üìå 'Bureaucrat::' --> clase padre
üìå 'GradeTooHighException::' --> clase derivada. what() pertenece a la derichada que a su vex pertenece a la parent
üìå 'const' --> no se va a modificar ningun miembro privado
üìå 'throw()' -->  es obligatorio porque la funci√≥n base std::exception::what() lo tiene

-----USABILIDAD DE LA CLASE DE EXCEPCION----

THROW

dentro de alguna funcion donde se deba corroborar:

if(grade < 1)
		throw GradeTooLowException();
	
üìå'throw' --> lanza una excepci√≥n. Es como decir: "¬°Ocurri√≥ un error grave! Deten√© lo que estabas haciendo y salt√° al bloque catch 
que pueda manejar este tipo de error."
Cuando se ejecuta throw, el flujo normal del programa se interrumpe y se empieza a buscar un bloque try-catch que pueda atrapar la excepci√≥n.


BLOQUE TRY - CATCH

Cuando lanz√°s una excepci√≥n con throw, C++ necesita saber qu√© hacer con ese error. Ah√≠ entra el try - catch.

va en main:

try {
    // C√≥digo que *puede* lanzar una excepci√≥n
} catch (tipo_de_excepcion& e) {
    // C√≥digo para manejar esa excepci√≥n
}

    try 
    {
        Bureaucrat b("Pepe", 200); // ‚ùå grade inv√°lido ‚Üí lanza una excepci√≥n (si fuera 50 no habria problema)
    } 
    catch (std::exception &e)
    {
       std::cerr << "Exception: " << e.what() << std::endl; //o cout???
    }

üß† catch (TipoDeExcepcion &nombreVariable)
üìå '&e' ‚Üí referencia a la excepci√≥n lanzada, y 'e' es simplemente el nombre de la variable con la que vas a acceder a la excepci√≥n.

¬øQu√© es un operador sobrecargado?
Cuando hablamos de "sobrecargar" un operador en C++, significa que estamos definiendo 
un nuevo comportamiento para un operador est√°ndar (como +, -, <<, >>, etc.) 


std::cout << First << std::endl; //‚ÄúLlam√° a mi operator<< personalizado con First como segundo par√°metro.‚Äù
recordar que el operador sobrecargado tiene como parametros:
operator<<(std::ostream &out, const Bureaucrat &b)

por ende espera recibir un objeto de la clase a la cual va a acceder a sus parametros por medio de los getter


DEFAULT CONSTRUCTOR TIENE QUE PDOER ASIGNAR VALOR A LOS PARAMETROS PRIVADOS




----EX01----


‚úÖ que pasa cuando tenemos CONSt en los atributos privados??

no pueden asignarse en el cuerpo del constructor.
Solo pueden inicializarse una vez, y debe ser en la lista de inicializaci√≥n del constructor, justo despu√©s de los dos puntos :.

‚ùó y como hacemos en el copy assignment operator? (=)

‚ùåthis->_gradeToSign = copy.getGradeToSign();
‚ùåthis->_gradeToExecute = copy.getGradeToExecute();

No pod√©s asignar nuevos valores a los miembros const, por lo tanto: Lo que se hace en la pr√°ctica es copiar solo los miembros que s√≠ son modificables, 
y dejar los const como est√°n desde la construcci√≥n original.

‚ùóy con el copy constructor?
Aca no hay problema porque el nuevo objeto se crea apartir del otro




----EX03----



alternativa a IF / ELSE IF

cuando necesitamos encadenar un if con un string and una accion. podemos hacerlo creando dos arrays

1) el primer array tendra los nombres que espera recibir, con los que va a hacer la comparacion "if (target == "robotomy request")"

const std::string formNames[] = {"presidental pardon", "robotomy request", "shrubbery creation"};

2) el segundo va a ser un array de funciones que tenemos que crear como auxiliares.
estas funciones solo aparecen en el file en cuestion y no se declaran en ningun header

AForm* (*formCreator[])(const std::string _target) = {CreateShrubbery, CreateRobotomy, CreatePardon};
	
	
3) Luego hacer uno for loop:

	for (int i = 0; i < 3; i++)
	{
		if(formNames[i] == form)
		{
			std::cout << "Intern creates " << form << std::endl;
			return (formCreator[i](target));
		}
	}
	std::cerr << RED << "ERROR404: ‚úó form not found ‚úó" << RESET << std::endl;

4)los helpers:

AForm* CreateRobotomy(std::string target)
{
	return new RobotomyRequestForm(target);
}



