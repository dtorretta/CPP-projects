‚úÖ ¬øQu√© son las clases de excepci√≥n en C++?
Las clases de excepci√≥n son tipos especiales de clases que se usan para representar errores o situaciones excepcionales en un programa.
Cuando algo sale mal (por ejemplo, divisi√≥n por cero, archivo no encontrado, etc.), puedes "lanzar" (throw) una excepci√≥n, y despu√©s "atraparla" (catch)
para manejar el error sin que el programa se caiga.

Hereda de:
std::exception, (recomendado) o alguna de sus hijas 
std::runtime_error, 
std::invalid_argument, etc.

Puedes crear tus propias clases de excepci√≥n si quer√©s errores m√°s espec√≠ficos y personalizados.
No necesitan estar en Orthodox Canonical Form, porque no manejan recursos complejos.


esta clase puede ir aparte o se puede agregar dentro de una clase principal

üí° Cuando la asignamos entro de la clase. Dentro de los miembros publicos agregamos

----DEFINICION DE LA EXCEPCION----

class GradeTooHighException : public std::exception 
{
	public:
		const char* what() const throw();
};

üìå 'class' --> agrago la palabra CLASS
üìå 'GradeTooHighException' -->nombre de la clase
üìå ': public std::exception' --> significa que esta clase es una subclase de std::exception.
es esencial para que pueda ser lanzada (throw) y capturada (catch) como cualquier excepci√≥n est√°ndar.
(en otros Cependant, habiamos hecho 'class FragTrap : public ClapTrap')

üìå'const char*' --> va a devolver un puntero a un string
üìå'what()' --> funcion heredada de std::exception. vSiempre se llama what(). Es lo que C++ usa para imprimir el mensaje de una excepci√≥n.
üìå'const' --> Es obligatorio para que coincida exactamente con la definici√≥n en std::exception.
üìå'throw()' --> Significa: "esta funci√≥n no lanza excepciones". equivalente a noexcept



----DECLARACION DE LA EXCEPCION----

const char* Bureaucrat::GradeTooHighException::what() const throw() 
{
    return "Grade is too high!";
}

üìå 'const char*' --> igual que en la definicion
üìå 'Bureaucrat::' --> clase padre
üìå 'GradeTooHighException::' --> clase derivada. what() pertenece a la derichada que a su vex pertenece a la parent
üìå 'const' --> no se va a modificar ningun miembro privado
üìå 'throw()' -->  es obligatorio porque la funci√≥n base std::exception::what() lo tiene

-----USABILIDAD DE LA CLASE DE EXCEPCION----

THROW

dentro de alguna funcion donde se deba corroborar:

if(grade < 1)
		throw GradeTooLowException();
	
üìå'throw' --> lanza una excepci√≥n. Es como decir: "¬°Ocurri√≥ un error grave! Deten√© lo que estabas haciendo y salt√° al bloque catch 
que pueda manejar este tipo de error."
Cuando se ejecuta throw, el flujo normal del programa se interrumpe y se empieza a buscar un bloque try-catch que pueda atrapar la excepci√≥n.


BLOQUE TRY - CATCH

Cuando lanz√°s una excepci√≥n con throw, C++ necesita saber qu√© hacer con ese error. Ah√≠ entra el try - catch.

va en main:

try {
    // C√≥digo que *puede* lanzar una excepci√≥n
} catch (tipo_de_excepcion& e) {
    // C√≥digo para manejar esa excepci√≥n
}

    try 
    {
        Bureaucrat b("Pepe", 200); // ‚ùå grade inv√°lido ‚Üí lanza una excepci√≥n (si fuera 50 no habria problema)
    } 
    catch (std::exception &e)
    {
       std::cerr << "Exception: " << e.what() << std::endl; //o cout???
    }

üß† catch (TipoDeExcepcion &nombreVariable)
üìå '&e' ‚Üí referencia a la excepci√≥n lanzada, y 'e' es simplemente el nombre de la variable con la que vas a acceder a la excepci√≥n.

¬øQu√© es un operador sobrecargado?
Cuando hablamos de "sobrecargar" un operador en C++, significa que estamos definiendo 
un nuevo comportamiento para un operador est√°ndar (como +, -, <<, >>, etc.) 


std::cout << First << std::endl; //‚ÄúLlam√° a mi operator<< personalizado con First como segundo par√°metro.‚Äù
recordar que el operador sobrecargado tiene como parametros:
operator<<(std::ostream &out, const Bureaucrat &b)

por ende espera recibir un objeto de la clase a la cual va a acceder a sus parametros por medio de los getter


DEFAULT CONSTRUCTOR TIENE QUE PDOER ASIGNAR VALOR A LOS PARAMETROS PRIVADOS


