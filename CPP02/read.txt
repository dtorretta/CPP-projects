Persona& operator=(const Persona& other);

Se usa para definir el comportamiento de la asignaci√≥n entre objetos (p1 = p2)
Si no lo definimos manualmente, C++ simplemente copia los valores de los atributos por defecto.
Si la clase tiene punteros din√°micos, la copia por defecto solo copiar√≠a la direcci√≥n de memoria, 
lo que podr√≠a causar doble delete en el destructor (üí• error de doble free).

para ellos la funcion 'Copy assignment operator' copia los datos manualmente.
Si hay punteros, crea una nueva copia en memoria en lugar de copiar la direcci√≥n.

el primer '&' en 'Persona&' indica que la funci√≥n devuelve una referencia al objeto actual (*this)
una referencia al objeto actual permite asignaciones encadenadas. 
sin el '&' devolveria una copia del objeto entonces cada vez que asignemos, 
se har√≠a una copia nueva del objeto en vez de modificar p1 directamente. --> Se crean objetos temporales innecesarios 


el segundo '&' en '(const Persona& other)' es meramente para evitar que se pase el parametro como copia. EFICIENCIA
De esta forma 'other' se pasa como una referencia
const tambi√©n mejora la seguridad, asegurando que other no se modifique dentro de operator=. EFICIENCIA


üöÄ EL & ES MERAMENTE POR EFICIENCIA
La diferencia clave es que, sin el & en operator=, se crear√°n copias innecesarias cada vez que se haga una asignaci√≥n.


üî• El concepto es muy similar al uso de punteros en C para evitar copias y mejorar eficiencia. 

Pero hay una raz√≥n clave por la que en C++ usamos referencias (&) en lugar de punteros (*) en operator=:

+ Las referencias (&) siempre apuntan a un objeto v√°lido (no pueden ser nullptr).
+ Si usamos punteros en operator=, tendr√≠amos que verificar si this es nullptr y manejarlo con m√°s cuidado.
+ los punteros no permite asignaciones encadenadas (En lugar de hacer p1 = p2 = p3;, tendr√≠amos que escribir *p1 = *p2 = *p3;)

‚ö†Ô∏è Se podr√≠a usar punteros (*), siempre que verifiques que no sean nullptr, pero no es la forma recomendada en C++. ‚ö†Ô∏è
En C, se usan punteros (*). En C++, se prefieren referencias (&) cuando sea posible.



-------------
Los n√∫meros de punto fijo (fixed-point numbers) son una alternativa a los enteros (int) y a los de punto flotante (float/double), 
dise√±ados para ofrecer un equilibrio entre precisi√≥n, rango y eficiencia.

Precisi√≥n:
Int: Solo valores enteros
Float: Precisi√≥n variable, errores de redondeo.	
fixed-point: Precisi√≥n controlada, sin errores de redondeo.

En vez de guardar 1.5 como 1.5, lo guardamos como 150 y recordamos que los dos √∫ltimos d√≠gitos representan decimales.
Este m√©todo es lo que llamamos n√∫meros en punto fijo.

Cuando el enunciado dice que "el n√∫mero de bits fraccionarios ser√° 8", 
significa que la computadora va a dividir el n√∫mero guardado por 256 (porque 2^8 = 256) para obtener su versi√≥n decimal real.
 
 
-------------
üìå ¬øQu√© es const en C++?
const en los par√°metros de una funci√≥n: Indica que el valor del par√°metro no debe ser modificado dentro de la funci√≥n.
const en los m√©todos de una clase: Indica que el m√©todo(funcion) no va a modificar el estado del objeto sobre el que se invoca.
(es decir, asignar algo dentro de la funcion. si es const no puedo dentro de la fx hacer _fixedPointNumber == raw )
Adem√°s, un objeto const solo puede invocar m√©todos const.


STATIC
Una funci√≥n static en una clase significa que no depende de una instancia espec√≠fica de la clase. 
Es decir, puedes llamarla sin necesidad de tener un objeto de esa clase.

que un parametro sea static, significa que esta variable pertenece a la clase y no a las instancias (objetos) de la clase.
si no dijera static Cada objeto (Fixed a; Fixed b;) tendr√≠a su propia copia de fractionalBits.

al ser static, se define como variable global:
const int Fixed::_fractionalBits = 8;