*std::vector* es parte de la STL y funciona como un array dinÃ¡mico.
A diferencia de un array tradicional (int arr[10]), el vector puede crecer o reducir 
su tamaÃ±o en tiempo de ejecuciÃ³n.
podÃ©s agregar mÃ¡s nÃºmeros cuando quieras con *.push_back()*

ğŸ§© typename T::iterator easyfind(T& container, int value) 

lo importante aca es que el retorno es un algoritmo "iterator"
Queremos devolver un iterador que apunta al nÃºmero buscado dentro del contenedor.
RETORNA UN POINTER

âš ï¸ container.end() --> no es el ultimo elemento del array sino el NULL final

âœ… ITERADOR == equivale a puntero en C


ğŸ“Œ algoritmos usados:
- ::iterator   --> retorna un iterator
- std::find
- std::distance
- std::sort
- std::min_element
- std::max_element
- .insert      -->  _Array.insert(_Array.end(), begin, end);   donde begin y end son pointer de otro vector
- std::adjacent_difference  --> (begin, end, temporal vector donde almacenar las distancias)
- .erase       --> (begin) para eliminar el primer elemento

	
ğŸ“Œ container usados:

- std::vector<int> NAME;   --> array de int
- std::list<int> myList;    --> double linked list
- std::stack


ğŸ§± Â¿QuÃ© es std::stack?
std::stack es un contenedor adaptador, o sea:
ğŸ”¹ No guarda los datos directamente,
ğŸ”¹ Usa otro contenedor por debajo para almacenar los elementos (como un std::vector o std::deque),
ğŸ”¹ Ese contenedor interno se llama c, y estÃ¡ marcado como protected.

Este c no es visible desde afuera si solo usÃ¡s std::stack, Â¡pero si hacÃ©s herencia, podÃ©s acceder a Ã©l!

âœ… Operaciones principales:
push(x) â†’ mete un elemento al tope.
pop() â†’ saca el elemento del tope.
top() â†’ accede al elemento del tope. es decir, el ultimo elemento insertado
size() â†’ cantidad de elementos.


Dentro de los contenedores estÃ¡ndar de C++ como std::vector, std::deque, std::list, etc., 
ya vienen definidos tipos de iteradores con nombres estÃ¡ndar. Es parte del diseÃ±o del STL.

std::vector<int>::iterator              // iterador mutable (puede modificar elementos)  --> puntero normal
std::vector<int>::const_iterator        // iterador constante (solo lectura)   --> igual que el anterior pero solo lectura
std::vector<int>::reverse_iterator      // iterador que va hacia atrÃ¡s (rbegin(), rend())  -->  puntero que va de atras para adelante
std::vector<int>::const_reverse_iterator// reverso solo lectura  --> igual que el anterior pero solo lectura

Los contenedores tambiÃ©n tienen funciones como:

begin()
end()
rbegin()
rend()


typedef typename std::stack<T>::container_type::iterator it;

typedef crea un apodo. 
IT ahora es un alias para el tipo iterador del contenedor interno del stack.
me ahorro de escribir toda la linea larga y solo escribo ahora it

        
ğŸ” Â¿QuÃ© hace un reverse_iterator?
Un reverse_iterator recorre el contenedor de atrÃ¡s hacia adelante.

Por ejemplo, si tenÃ©s este contenedor:

std::vector<int> v = {10, 20, 30};

v.begin() apunta a 10
v.end() apunta despuÃ©s de 30 (a un elemento invÃ¡lido)
v.rbegin() apunta a 30 âœ…
v.rend() apunta antes de 10 (tambiÃ©n invÃ¡lido, marca el fin del reverso)